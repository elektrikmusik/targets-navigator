name: Deploy to VPS

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: "Skip tests (emergency deployment)"
        required: false
        default: false
        type: boolean

# Security: Prevent workflow from running on forks
permissions:
  contents: read
  security-events: write
  actions: read
  id-token: write

env:
  NODE_VERSION: "20"
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  validate:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      skip_tests: ${{ steps.check.outputs.skip_tests }}

    steps:
      - name: Check deployment conditions
        id: check
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "skip_tests=${{ github.event.inputs.skip_tests }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" == "refs/heads/main" ] && [ "${{ github.event_name }}" == "push" ]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "skip_tests=false" >> $GITHUB_OUTPUT
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "skip_tests=false" >> $GITHUB_OUTPUT
          fi

  security-scan:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: needs.validate.outputs.skip_tests != 'true'
    needs: validate

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for secrets
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: HEAD~1
          head: HEAD
          extra_args: --debug --only-verified

      - name: Run CodeQL Analysis
        uses: github/codeql-action/init@v3
        with:
          languages: typescript, javascript

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3

  test:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: needs.validate.outputs.skip_tests != 'true'
    needs: validate

    strategy:
      matrix:
        node-version: [18, 20]
        fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: "npm"
          registry-url: https://registry.npmjs.org

      - name: Cache node_modules
        uses: actions/cache@v3
        with:
          path: |
            ~/.npm
            node_modules
          key: ${{ runner.os }}-node-${{ matrix.node-version }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-${{ matrix.node-version }}-

      - name: Install dependencies
        run: npm ci --legacy-peer-deps --prefer-offline --no-audit

      - name: Type checking
        run: npx tsc --noEmit

      - name: Run linter
        run: npm run lint

      - name: Security audit
        run: |
          npm audit --audit-level=high --omit=dev || {
            echo "Security vulnerabilities found in production dependencies"
            npm audit --audit-level=high --omit=dev --json > audit-results.json
            echo "Audit results saved to audit-results.json"
            exit 1
          }

      - name: Build application
        run: npm run build
        env:
          NODE_ENV: production
          VITE_SUPABASE_URL: ${{ secrets.VITE_SUPABASE_URL }}
          VITE_SUPABASE_ANON_KEY: ${{ secrets.VITE_SUPABASE_ANON_KEY }}

      - name: Test build output
        run: |
          if [ ! -d "dist" ]; then
            echo "Build failed: dist directory not found"
            exit 1
          fi
          if [ ! -f "dist/index.html" ]; then
            echo "Build failed: index.html not found"
            exit 1
          fi
          echo "Build size: $(du -sh dist/)"

      - name: Upload build artifacts (Primary Node Version)
        if: matrix.node-version == 20
        uses: actions/upload-artifact@v4
        with:
          name: build-files-${{ github.run_id }}
          path: dist/
          retention-days: 7

  deploy:
    needs: [validate, test, security-scan]
    runs-on: ubuntu-latest
    if: always() && needs.validate.outputs.should_deploy == 'true' && (success() || needs.validate.outputs.skip_tests == 'true')
    timeout-minutes: 20
    environment:
      name: production
      url: https://targets.srv903155.hstgr.cloud

    steps:
      - name: Checkout deployment scripts
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/
            deploy-production.sh
            docker-compose.prod.yml
            nginx.conf
            Dockerfile

      - name: Download build artifacts
        if: needs.validate.outputs.skip_tests != 'true'
        uses: actions/download-artifact@v4
        with:
          name: build-files-${{ github.run_id }}
          path: dist/

      - name: Validate required secrets
        run: |
          echo "üîç Validating required secrets..."
          missing_secrets=""

          if [ -z "${{ secrets.VPS_SSH_KEY }}" ]; then
            missing_secrets="${missing_secrets}VPS_SSH_KEY "
          fi
          if [ -z "${{ secrets.VPS_HOST }}" ]; then
            missing_secrets="${missing_secrets}VPS_HOST "
          fi
          if [ -z "${{ secrets.VPS_USERNAME }}" ]; then
            missing_secrets="${missing_secrets}VPS_USERNAME "
          fi
          if [ -z "${{ secrets.VITE_SUPABASE_URL }}" ]; then
            missing_secrets="${missing_secrets}VITE_SUPABASE_URL "
          fi
          if [ -z "${{ secrets.VITE_SUPABASE_ANON_KEY }}" ]; then
            missing_secrets="${missing_secrets}VITE_SUPABASE_ANON_KEY "
          fi

          if [ -n "$missing_secrets" ]; then
            echo "‚ùå Missing required secrets: $missing_secrets"
            echo "üìã Please add these secrets to your repository settings"
            exit 1
          fi

          echo "‚úÖ All required secrets are present"

      - name: Validate SSH Key Format
        run: |
          echo "üîç Validating SSH key format..."

          # Check if key starts with proper header
          if [[ "${{ secrets.VPS_SSH_KEY }}" == -----BEGIN* ]]; then
            echo "‚úÖ SSH key format appears correct (PEM format)"
          else
            echo "‚ùå SSH key format incorrect. Expected: -----BEGIN [KEY TYPE] PRIVATE KEY-----"
            exit 1
          fi

          # Check key length (basic validation)
          KEY_LENGTH=$(echo "${{ secrets.VPS_SSH_KEY }}" | wc -c)
          echo "üìè SSH key length: $KEY_LENGTH characters"

          if [ $KEY_LENGTH -lt 1000 ]; then
            echo "‚ùå SSH key too short (expected >1000 chars)"
            exit 1
          fi

          # Check for common SSH key issues
          if [[ "${{ secrets.VPS_SSH_KEY }}" == *"ssh-rsa"* ]]; then
            echo "‚ùå You've provided the PUBLIC key instead of the PRIVATE key"
            exit 1
          fi

          echo "‚úÖ SSH key validation passed"

      - name: Test SSH Connection
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          timeout: 30s
          script: |
            echo "üîç Testing SSH connection..."
            echo "Host: ${{ secrets.VPS_HOST }}"
            echo "Username: ${{ secrets.VPS_USERNAME }}"
            echo "Port: ${{ secrets.VPS_PORT || 22 }}"
            echo "Current user: $(whoami)"
            echo "Current directory: $(pwd)"
            echo "System info: $(uname -a)"
            echo "‚úÖ SSH connection successful!"

      - name: Create deployment backup
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          timeout: 60s
          script: |
            set -e
            echo "üóÑÔ∏è Creating deployment backup..."

            # Create backup directory if it doesn't exist
            mkdir -p /opt/targets-navigator/backups

            # Create backup with timestamp
            BACKUP_NAME="backup-$(date +'%Y%m%d-%H%M%S')-${{ github.sha }}"

            # Backup current containers if they exist
            if docker ps -q -f name="targets-navigator" | grep -q .; then
              echo "Creating container backup: $BACKUP_NAME"
              docker commit targets-navigator-app targets-navigator:$BACKUP_NAME || echo "No running container to backup"
            fi

            echo "‚úÖ Backup created: $BACKUP_NAME"

      - name: Deploy to VPS
        id: deploy
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          timeout: 10m
          command_timeout: 15m
          script: |
            set -euo pipefail

            echo "üöÄ Starting deployment process..."
            echo "Deployment ID: ${{ github.run_id }}"
            echo "Commit SHA: ${{ github.sha }}"
            echo "Timestamp: $(date)"

            # Function to log with timestamps
            log() {
                echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1"
            }

            # Navigate to application directory
            cd /opt/targets-navigator || {
                log "‚ùå Application directory not found. Creating..."
                sudo mkdir -p /opt/targets-navigator
                sudo chown $(whoami):$(whoami) /opt/targets-navigator
                cd /opt/targets-navigator
            }

            # Initialize or update git repository
            if [ ! -d .git ]; then
                log "üì• Cloning repository..."
                git clone https://github.com/elektrikmusik/targets-navigator.git .
            else
                log "üì• Pulling latest changes..."
                git fetch origin
                git reset --hard origin/main
            fi

            # Verify required files exist
            log "üîç Verifying deployment files..."
            for file in "docker-compose.prod.yml" "Dockerfile" "nginx.conf"; do
                if [ ! -f "$file" ]; then
                    log "‚ùå Required file missing: $file"
                    exit 1
                fi
            done

            # Create comprehensive .env.production file
            log "üìù Creating production environment file..."
            cat > .env.production << 'EOF'
            # Application Configuration
            VITE_SUPABASE_URL=${{ secrets.VITE_SUPABASE_URL }}
            VITE_SUPABASE_ANON_KEY=${{ secrets.VITE_SUPABASE_ANON_KEY }}
            VITE_APP_ENV=production
            NODE_ENV=production

            # System Configuration
            TZ=UTC

            # Monitoring Configuration
            GRAFANA_ADMIN_PASSWORD=admin123

            # Nginx Configuration
            NGINX_WORKER_PROCESSES=auto
            NGINX_WORKER_CONNECTIONS=1024
            LOG_LEVEL=info
            ACCESS_LOG_FORMAT=main

            # Compression Settings
            GZIP_COMPRESSION=on
            BROTLI_COMPRESSION=off

            # Cache Settings
            CACHE_STATIC_ASSETS=1y
            CACHE_HTML_FILES=1h

            # Rate Limiting
            RATE_LIMIT_API=10r/s
            RATE_LIMIT_STATIC=30r/s
            RATE_LIMIT_BURST=20

            # Health Check Configuration
            HEALTH_CHECK_INTERVAL=30s
            HEALTH_CHECK_TIMEOUT=10s
            HEALTH_CHECK_RETRIES=3

            # GitHub Actions Metadata
            GITHUB_RUN_ID=${{ github.run_id }}
            GITHUB_SHA=${{ github.sha }}
            DEPLOYMENT_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            EOF

            # Ensure Traefik network exists
            log "üîó Ensuring Traefik network exists..."
            docker network ls | grep -q "traefik" || docker network create traefik

            # Stop existing containers gracefully with timeout
            log "üõë Stopping existing containers..."
            timeout 60 docker-compose -f docker-compose.prod.yml down --remove-orphans || {
                log "‚ö†Ô∏è Graceful shutdown failed, forcing container stop..."
                docker-compose -f docker-compose.prod.yml kill
                docker-compose -f docker-compose.prod.yml rm -f
            }

            # Prune Docker system to free space
            log "üßπ Cleaning Docker system..."
            docker system prune -af --volumes || log "‚ö†Ô∏è Docker cleanup partially failed"

            # Build new containers
            log "üî® Building application containers..."
            DOCKER_BUILDKIT=1 docker-compose -f docker-compose.prod.yml build \
                --no-cache \
                --pull \
                --parallel || {
                log "‚ùå Container build failed"
                exit 1
            }

            # Start containers in detached mode
            log "üöÄ Starting application containers..."
            docker-compose -f docker-compose.prod.yml up -d || {
                log "‚ùå Failed to start containers"
                log "üìã Container status:"
                docker-compose -f docker-compose.prod.yml ps
                log "üìã Container logs:"
                docker-compose -f docker-compose.prod.yml logs --tail=50
                exit 1
            }

            # Wait for application startup
            log "‚è≥ Waiting for application to initialize..."
            sleep 30

            # Comprehensive health check with retries
            log "üè• Performing health checks..."
            HEALTH_CHECK_URL="http://localhost:8080/health"
            MAX_ATTEMPTS=10
            ATTEMPT=1

            while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
                log "Health check attempt $ATTEMPT/$MAX_ATTEMPTS"
                
                # Check if container is running
                if ! docker-compose -f docker-compose.prod.yml ps | grep -q "Up"; then
                    log "‚ùå Container is not running"
                    docker-compose -f docker-compose.prod.yml ps
                    docker-compose -f docker-compose.prod.yml logs --tail=20
                    exit 1
                fi
                
                # Check health endpoint
                if curl -f -s --max-time 10 "$HEALTH_CHECK_URL" > /dev/null 2>&1; then
                    log "‚úÖ Health check passed!"
                    break
                elif [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
                    log "‚ùå Health check failed after $MAX_ATTEMPTS attempts"
                    log "üìã Final container status:"
                    docker-compose -f docker-compose.prod.yml ps
                    log "üìã Application logs:"
                    docker-compose -f docker-compose.prod.yml logs --tail=50
                    exit 1
                else
                    log "‚è≥ Health check failed, retrying in 15 seconds..."
                    sleep 15
                fi
                
                ((ATTEMPT++))
            done

            # Verify external accessibility
            log "üåê Verifying external accessibility..."
            if curl -f -s --max-time 10 "http://localhost:8080/" > /dev/null 2>&1; then
                log "‚úÖ Application is accessible via HTTP"
            else
                log "‚ö†Ô∏è Application may not be externally accessible"
            fi

            # Final deployment status
            log "üìä Deployment Summary:"
            echo "==================="
            docker-compose -f docker-compose.prod.yml ps
            echo ""
            log "üíæ Disk usage:"
            df -h / | tail -1
            echo ""
            log "üê≥ Docker images:"
            docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}\t{{.CreatedAt}}" | head -5

            log "‚úÖ Deployment completed successfully!"
            log "üåç Application URL: https://targets.srv903155.hstgr.cloud"
            log "üïê Deployment finished at: $(date)"

      - name: Post-deployment verification
        if: success()
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          timeout: 60s
          script: |
            echo "üîç Post-deployment verification..."

            # Wait a bit more for full initialization
            sleep 10

            # Final comprehensive check
            if curl -f -s --max-time 15 "https://targets.srv903155.hstgr.cloud" > /dev/null 2>&1; then
                echo "‚úÖ Production site is live and accessible!"
            else
                echo "‚ö†Ô∏è Production site verification failed - may need time to propagate"
                # Don't fail the deployment for this
            fi

            # Log final container status
            echo "üìä Final container status:"
            cd /opt/targets-navigator
            docker-compose -f docker-compose.prod.yml ps

  post-deployment:
    needs: deploy
    runs-on: ubuntu-latest
    if: always()
    timeout-minutes: 5

    steps:
      - name: Deployment notification
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "üéâ DEPLOYMENT SUCCESSFUL!"
            echo "‚úÖ Application deployed to: https://targets.srv903155.hstgr.cloud"
            echo "üìù Deployment ID: ${{ github.run_id }}"
            echo "üîó Commit: ${{ github.sha }}"
            echo "üë§ Deployed by: ${{ github.actor }}"
            echo "üïê Completed at: $(date -u)"
          else
            echo "‚ùå DEPLOYMENT FAILED!"
            echo "üîç Check the deployment logs above for details"
            echo "üìù Deployment ID: ${{ github.run_id }}"
            echo "üîó Failed commit: ${{ github.sha }}"
            echo "üë§ Attempted by: ${{ github.actor }}"
          fi

      - name: Cleanup artifacts
        if: always()
        uses: geekyeggo/delete-artifact@v2
        with:
          name: build-files-${{ github.run_id }}
          failOnError: false
